<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.3 on Fri May 10 14:25:36 2024 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>advanced_spectral_fit.pro (AmesPAHdbIDLSuite Manual)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="advanced_spectral_fit.pro (AmesPAHdbIDLSuite Manual)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="container">
      <div class="content">
	<code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; This is an example of fitting an astronomical spectrum and</span>
<span class="comments">; optimizing several parameters describing the astrophysical</span>
<span class="comments">; environment, built around the functionality provided by the</span>
<span class="comments">; AmesPAHdbIDLSuite and should help confirm that the it has been</span>
<span class="comments">; properly installed. The source code is annotated to guide users and</span>
<span class="comments">; developers in the inner workings of the suite.</span>
<span class="comments">;</span>
<span class="comments">; Updated versions of the NASA Ames PAH IR Spectroscopic Database and</span>
<span class="comments">; more information can be found at: `www.astrochemistry.org/pahdb &lt;https://www.astrochemistry.org/pahdb>`.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   Call the procedure directly::</span>
<span class="comments">;</span>
<span class="comments">;     IDL> advanced_spectral_fit</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   Dr. Christiaan Boersma</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;   BSD licensed</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Changes::</span>
<span class="comments">;</span>
<span class="comments">;     05-03-2022</span>
<span class="comments">;     Add plotting size distribution. Exclude fully-dehydrogenated PAHs.</span>
<span class="comments">;     Plot using wavelength. Christiaan Boersma.</span>
<span class="comments">;     08-19-2019</span>
<span class="comments">;     Documentation added. Christiaan Boersma.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Callback function running a spectroscopy database-fit iteration.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   p: in, required, type=double array</span>
<span class="comments">;     Parameter values</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   scalar (double)</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   CALLBACK</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
FUNCTION FUNC,p

  COMPILE_OPT IDL2

  <span class="comments">; common block</span>
  COMMON _func,pahdb,uids,nuids,ncarbon,observation,options,fit,nfit

  <span class="comments">; translate and check parameters</span>
  i = 0

  IF options.model GT 0 THEN BEGIN

     IF options.input LE 0 THEN BEGIN

        input = p[i++]

        IF input LE 0 THEN RETURN,(MACHAR(/DOUBLE)).xmax

     ENDIF ELSE input = options.input

  ENDIF ELSE input = 0.0D

  IF options.width LE 0 THEN BEGIN

     width = p[i++]

     IF width LE 0 THEN RETURN,(MACHAR(/DOUBLE)).xmax

  ENDIF ELSE width = options.width

  IF options.redshift GT 0 THEN BEGIN

     redshift = p[i++]

     IF redshift GT 0 THEN RETURN,(MACHAR(/DOUBLE)).xmax

  ENDIF ELSE redshift = options.redshift

  IF options.balance LT 0 AND options.Tgas LT 0 THEN BEGIN

     balance = p[i++]

     IF balance LT 0 THEN RETURN,(MACHAR(/DOUBLE)).xmax

  ENDIF ELSE balance = options.balance

  IF options.Tgas LT 0 THEN BEGIN

     Tgas = p[i++]

     IF Tgas LT 0 THEN RETURN,(MACHAR(/DOUBLE)).xmax

  ENDIF ELSE Tgas = options.Tgas

  <span class="comments">; increment nfit</span>
  nfit++

  <span class="comments">; retrieve the transitions from the database</span>
  IF options.balance NE 0 AND options.Tgas NE 0 THEN transitions = pahdb->GetTransitionsByUID(REFORM(uids, nuids * 3)) $
  ELSE transitions = pahdb->GetTransitionsByUID(uids)

  <span class="comments">; turn into emission spectrum</span>
  CASE options.model OF

     0 : BREAK

     1 : transitions->FixedTemperature,input

     2 : transitions->CalculatedTemperature,input*1.6021765D-12,Star=options.star

     3 : transitions->Cascade,input*1.6021765D-12,Star=options.star

  ENDCASE

  IF redshift LT 0 THEN transitions->Shift,redshift

  IF options.balance NE 0 AND options.Tgas NE 0 THEN BEGIN

    <span class="comments">; intersect</span>
    transitions->Intersect,uids[0,*]

    <span class="comments">; retrieve data in struct</span>
    t = transitions->Get()

    <span class="comments">; use a working copy</span>
    c = t

    <span class="comments">; merge the charges and assign pseudo identifiers</span>
    FOR i = 0, nuids - 1 DO BEGIN

       sel0 = WHERE(t.data.uid EQ uids[0, i])

       sel1 = WHERE(t.data.uid EQ uids[1, i])

       sel2 = WHERE(t.data.uid EQ uids[2, i])

       c.data[[sel0, sel1, sel2]].uid = i + 1

       c.data[sel0].intensity *= 1.6D2 / SQRT(ncarbon[0, i]) / balance

       c.data[sel2].intensity *= 5.11D-6 * SQRT(ncarbon[2, i]) * SQRT(Tgas) * balance

    ENDFOR

    <span class="comments">; set data</span>
    transitions->Set,Data=c.data,Uids=LINDGEN(nuids) + 1

  ENDIF

   <span class="comments">; create spectrum</span>
  spectrum = transitions->Convolve(Grid=observation->getGrid(), Gaussian=options.profile, FWHM=width)

  <span class="comments">; fit the spectrum</span>
  fit = spectrum->Fit(observation)

  <span class="comments">; clean up after ourselves</span>
  OBJ_DESTROY,[spectrum, transitions]

  <span class="comments">; chi-squared</span>
  chisq = fit->getChiSquared()

  <span class="comments">; norm</span>
  norm = fit->getNorm()

  <span class="comments">; print parameters</span>
  PRINT
  PRINT,FORMAT='(89("="),"'+STRING(10B)+'",A4,4X,A8,4X,A8,4X,A8,4X,A8,4X,A8,4X,A8,4X,A8)',"run","redshift","FWHM","gamma","Tgas","T/energy","norm","chi-sq"
  PRINT,FORMAT='(I4,4X,g8.3,4X,g8.3,4X,g8.3,4X,g8.3,4X,g8.3,4X,g8.3,4X,g8.3)',nfit,redshift,width,balance,Tgas,input,norm,chisq
  PRINT,FORMAT='(89("="))'
  PRINT


  <span class="comments">; return</span>
  IF options.minimize EQ 0 THEN RETURN,norm

  RETURN,chisq
END

<span class="comments">;+</span>
<span class="comments">; Procedure performing an advanced spectral fit.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   OPTS: in, optional, type=struct</span>
<span class="comments">;     Options</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   Example</span>
<span class="comments">;-</span>
PRO ADVANCED_SPECTRAL_FIT,OPTS

  COMPILE_OPT IDL2

  <span class="comments">; the Spitzer IRS/SL 10 - 15 micron spectrum of NGC7023</span>
  file = 'ngc7023.dat'

  <span class="comments">; create a common block and set options :</span>
  <span class="comments">; size:</span>
  <span class="comments">;   > 0 fixed</span>
  <span class="comments">; model:</span>
  <span class="comments">;   0 - none</span>
  <span class="comments">;   1 - FixedTemperature</span>
  <span class="comments">;   2 - CalculatedTemperature</span>
  <span class="comments">;   3 - Cascade</span>
  <span class="comments">; input:</span>
  <span class="comments">;  >0 - fixed</span>
  <span class="comments">; &lt;=0 - optimize</span>
  <span class="comments">; star:</span>
  <span class="comments">;    0 - no</span>
  <span class="comments">;    1 - yes</span>
  <span class="comments">; profile:</span>
  <span class="comments">;   0 - Lorentzian</span>
  <span class="comments">;   1 - Gaussian</span>
  <span class="comments">; width:</span>
  <span class="comments">; >=0 - fixed</span>
  <span class="comments">;  &lt;0 - optimize</span>
  <span class="comments">; redshift:</span>
  <span class="comments">; &lt;=0 - fixed</span>
  <span class="comments">;  >0 - optimize</span>
  <span class="comments">; balance (see Carelli et al. 2012 on electron attachement rates) :</span>
  <span class="comments">;   0 - disable</span>
  <span class="comments">;  >0 - fixed</span>
  <span class="comments">;  &lt;0 - optimize</span>
  <span class="comments">; Tgas:</span>
  <span class="comments">;   0 - disable</span>
  <span class="comments">;  >0 - fixed</span>
  <span class="comments">;  &lt;0 - optimize</span>
  <span class="comments">; minimize:</span>
  <span class="comments">;  0 - norm</span>
  <span class="comments">;  1 - chi-squared</span>
  <span class="comments">; query:</span>
  <span class="comments">;  string - search query</span>
  COMMON _func,pahdb,uids,nuids,ncarbon,observation,options,fit,nfit

  IF N_PARAMS() EQ 0 THEN options = {model:0, $
                                     input:0D, $
                                     star:0, $
                                     profile:1, $
                                     width:16D, $
                                     redshift:15D, $
                                     balance:0, $
                                     Tgas:0, $
                                     minimize:0, $
                                     query:"o=0 mg=0 fe=0 si=0 chx=0 ch2=0 c>=25 h>0"} $
  ELSE options = OPTS

  nfit = 0

  <span class="comments">; read observations into AmesPAHdbIDLSuite_Observation</span>
  observation = OBJ_NEW('AmesPAHdbIDLSuite_Observation', $
                        file, $
                        Units=AmesPAHdbIDLSuite_CREATE_OBSERVATION_UNITS_S(AUNIT=3, OUNIT=1))

  <span class="comments">; turn wavelength into frequency</span>
  observation->AbscissaUnitsTo,1

  <span class="comments">; hide overflow/underflow messages expected with Planck's function</span>
  <span class="comments">; and Gaussian emission profiles</span>
  IF options.model GT 1 OR options.profile EQ 1 THEN BEGIN

     except = !EXCEPT

     !EXCEPT = 0

  ENDIF

  <span class="comments">; read in the default database defined by the environement variable</span>
  <span class="comments">; !AMESPAHDEFAULTDB or the system variable AMESPAHDEFAULTDB. use the</span>
  <span class="comments">; keyword FILENAME if these have not been set</span>
  pahdb = OBJ_NEW('AmesPAHdbIDLSuite')

  IF options.balance NE 0 AND options.Tgas NE 0 THEN BEGIN

     <span class="comments">; get complete set of anion, neutral and cation species</span>
     uids = pahdb->getUIDsCompleteChargeSet(-1, nuids)

     <span class="comments">; get species and fill ncarbon</span>
     species = pahdb->getSpeciesByUID(REFORM(uids, nuids * 3))

     ncarbon = REFORM((species->get()).data.nc, 3, nuids)

     <span class="comments">; clean up species</span>
     OBJ_DESTROY,species

  ENDIF ELSE uids = pahdb->Search(options.query, nuids)

  <span class="comments">; optimize or not?</span>
  IF (options.model GT 0 AND options.input LE 0) OR $
     options.width LE 0 OR $
     options.redshift GT 0 OR $
     options.balance LT 0 OR $
     options.Tgas LT 0 THEN BEGIN

     <span class="comments">; initial guesses and scale</span>
     p0 = 0D

     scale = 0D

     IF options.model EQ 1 THEN BEGIN

        p0 = [p0, 850D]

        scale = [scale, 750D]

     ENDIF ELSE IF options.model GT 1 THEN BEGIN

        p0 = [p0, 5.5D]

        scale = [scale, 4.5D]

     ENDIF

     IF options.width LE 0 THEN BEGIN

        p0 = [p0, 16D]

        scale = [scale, 15D]

     ENDIF

     IF options.redshift GT 0 THEN BEGIN

        p0 = [p0, -15D]

        scale = [scale, -30D]

     ENDIF

     IF options.balance LT 0 THEN BEGIN

        p0 = [p0, 1.3D2]

        scale = [scale, 1.3D3]

     ENDIF

     IF options.Tgas LT 0 THEN BEGIN

        p0 = [p0, 600D]

        scale = [scale, 4D2]

     ENDIF

     p0 = p0[1:*]

     scale = scale[1:*]

     <span class="comments">; minimize parameters</span>
     param = AMOEBA(1D-5, P0=p0, SCALE=scale)

     IF N_ELEMENTS(param) EQ 1 THEN BEGIN

        IF param EQ -1 THEN BEGIN

           MESSAGE,"FAILED TO CONVERGE IN "+STRTRIM(STRING(nfit),2)+" ITERATIONS",/INFORMATIONAL

           GOTO,FINISH

        ENDIF

     ENDIF

  ENDIF ELSE param = [options.input, $
                      options.width, $
                      options.redshift, $
                      options.balance, $
                      options.Tgas]

  <span class="comments">; a single run to fill the fit object using the fixed and/or</span>
  <span class="comments">; optimized parameters</span>
  void = FUNC(param)

  <span class="comments">; translate parameters</span>
  i = 0

  IF options.model GT 0 THEN BEGIN

     IF options.input LE 0 THEN BEGIN

        input = param[i++]

     ENDIF ELSE input = options.input

  ENDIF ELSE input = 0.0D

  IF options.width LE 0 THEN BEGIN

     width = param[i++]

  ENDIF ELSE width = options.width

  IF options.redshift GT 0 THEN BEGIN

     redshift = param[i++]

  ENDIF ELSE redshift = options.redshift

  IF options.balance LT 0 THEN BEGIN

     balance = param[i++]

  ENDIF ELSE balance = options.balance

  IF options.Tgas LT 0 THEN BEGIN

     Tgas = param[i++]

  ENDIF ELSE Tgas = options.Tgas

  IF options.balance NE 0 AND options.Tgas NE 0 THEN BEGIN

     <span class="comments">; store the weights of the fitted combined spectra</span>
     f_weights = fit->getWeights()

     <span class="comments">; store the identifiers of the fitted combined species</span>
     f_uids = fit->getUIDS(nf_uids) - 1

     nn_uids = 3 * nf_uids

     <span class="comments">; store the identifiers of the individual species</span>
     n_uids = REFORM(uids[*, f_uids], nn_uids)

    <span class="comments">; new weights</span>
     n_weights = REPLICATE({AmesPAHdbIDLSuite_Weights_S, $
                            uid:0L, $
                            weight:0D}, nn_uids)

     <span class="comments">; get transitions of found species</span>
     transitions = pahdb->getTransitionsByUID(n_uids)

     <span class="comments">; turn into emission spectrum</span>
     CASE options.model OF

        0 : break

        1 : transitions->FixedTemperature,input

        2 : transitions->CalculatedTemperature,input*1.6021765D-12,Star=options.star

        3 : transitions->Cascade,input*1.6021765D-12,Star=options.star

     ENDCASE

     <span class="comments">; shift the transitions</span>
     IF redshift LT 0 THEN transitions->Shift,redshift

     <span class="comments">; convolve into spectra</span>
     spectrum = transitions->Convolve(FWHM=width, Gaussian=options.profile, Grid=observation->getGrid())

     <span class="comments">; get spectra in struct</span>
     s = spectrum->get()

     <span class="comments">; clean up</span>
     OBJ_DESTROY,[spectrum]

     <span class="comments">; use a working copy</span>
     c = s

     <span class="comments">; assign correct weights using the charge balance</span>
     FOR i = 0, nf_uids - 1 DO BEGIN

        n_weights[3*i].weight = f_weights[i].weight * 1.6D2 / SQRT(ncarbon[0, f_uids[i]]) / balance

        n_weights[3*i].uid = uids[0, f_uids[i]]

        n_weights[3*i+1].weight = f_weights[i].weight

        n_weights[3*i+1].uid = uids[1, f_uids[i]]

        n_weights[3*i+2].weight = f_weights[i].weight * 5.11D-6 * SQRT(ncarbon[2, f_uids[i]]) * SQRT(Tgas) * balance

        n_weights[3*i+2].uid = uids[2, f_uids[i]]


        sel0 = WHERE(s.data.uid EQ uids[0, f_uids[i]])

        sel1 = WHERE(s.data.uid EQ uids[1, f_uids[i]])

        sel2 = WHERE(s.data.uid EQ uids[2, f_uids[i]])


        c[sel0].data.intensity = s[sel0].data.intensity * n_weights[3*i].weight

        c[sel1].data.intensity = s[sel1].data.intensity * n_weights[3*i+1].weight

        c[sel2].data.intensity = s[sel2].data.intensity * n_weights[3*i+2].weight

     ENDFOR

     fit->Set,Data=c.data,Uids=n_uids,Weights=n_weights

  ENDIF

  <span class="comments">; restore underflow/overflow reporting</span>
  IF options.model GT 1 OR options.profile EQ 1 THEN !EXCEPT = except

  <span class="comments">; plot the fit</span>
  fit->Plot

  key = ''
  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  fit->Plot,/Residual,/Wavelength

  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  fit->Plot,/Charge,/Wavelength

  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  fit->Plot,/Size,/Wavelength

  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  fit->Plot,/Composition,/Wavelength

  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  fit->Plot,/DistributionSize

  IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

  <span class="comments">; predict 2 - 20 um spectrum</span>

  xrange = 1D4 / [20D, 3D]

  IF NOT OBJ_VALID(transitions) THEN transitions = pahdb->getTransitionsByUID(uids)

  spectrum = transitions->Convolve(FWHM=width, Gaussian=options.profile, XRange=xrange)

  coadded = spectrum->Coadd(Weights=n_weights)

  coadded->Plot,/Wavelength

  <span class="comments">; clean up the objects</span>
  OBJ_DESTROY,[coadded, spectrum, transitions, fit, observation, pahdb]

  FINISH:

END
</code>
      </div>
    </div>
  </body>
</html>