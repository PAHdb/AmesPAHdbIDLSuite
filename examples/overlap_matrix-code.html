<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.3 on Tue Apr  9 12:19:01 2024 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>overlap_matrix.pro (AmesPAHdbIDLSuite Manual)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="overlap_matrix.pro (AmesPAHdbIDLSuite Manual)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="container">
      <div class="content">
	<code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; This is an example of clustering (hierarchical) PAH emission spectra</span>
<span class="comments">; and should confirm that the AmesPAHdbIDLSuite has been correctly</span>
<span class="comments">; installed. The source code is annotated to guide users and</span>
<span class="comments">; developers in the inner workings of the suite.</span>
<span class="comments">;</span>
<span class="comments">; Updated versions of the NASA Ames PAH IR Spectroscopic Database and</span>
<span class="comments">; more information can be found at: `www.astrochemistry.org/pahdb &lt;https://www.astrochemistry.org/pahdb>`.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   Call the procedure directly::</span>
<span class="comments">;</span>
<span class="comments">;     IDL> overlap_matrix</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   Dr. Christiaan Boersma</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;   BSD licensed</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Changes::</span>
<span class="comments">;</span>
<span class="comments">;     08-19-2019</span>
<span class="comments">;     Documentation added. Christiaan Boersma.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Procedure performing a hierarchical split.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   Example</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   matrix: in, required, type=double array</span>
<span class="comments">;     n by n overlap matrix</span>
<span class="comments">;   depth: in, required, type=int</span>
<span class="comments">;     Current split</span>
<span class="comments">;   max_depth: in, required, type=int</span>
<span class="comments">;     Maximum number of splits</span>
<span class="comments">;   min_bins: in, required, type=int</span>
<span class="comments">;     Minimum number of members required to form a bin</span>
<span class="comments">;   bins: in, required, type=int array</span>
<span class="comments">;     Assigned cluster bin</span>
<span class="comments">;   parent: in, required, type=double array</span>
<span class="comments">;     Parent of current cluster</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   METRIC: in, optional, type=int</span>
<span class="comments">;     Whether to use a metric distance measure</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
PRO NODES,matrix,depth,max_depth,min_bins,bins,parent,METRIC=metric

  COMPILE_OPT IDL2

  MESSAGE,STRING(FORMAT='("DEPTH:",X,I0)', depth),/INFORMATIONAL

  IF depth GT 0 THEN d = depth - 1 $
  ELSE d = depth

  k = WHERE(bins[*,d] EQ parent, nbin)

  IF nbin LT min_bins THEN BEGIN

     MESSAGE,STRING(FORMAT='(A0,X,"(NBIN=",I0,")")', "SINGULAR DECOMPOSITION OR SPARSE BIN: DONE", nbin),/INFORMATIONAL

     bins[k,depth:*] = parent

     RETURN

  ENDIF

  void = MIN(matrix, imin, /NAN, SUBSCRIPT_MAX=imax)

  bin1 = parent * 2 + 1 & bin2 = bin1 + 1

  IF NOT KEYWORD_SET(metric) THEN ij = ARRAY_INDICES(matrix, imin) $
  ELSE ij = ARRAY_INDICES(matrix, imax)

  srt = SORT(ij)

  ij = ij[srt]

  MESSAGE,STRING(FORMAT='("BINS:",X,I0,X,"&",X,I0)',bin1,bin2),/INFORMATIONAL

  bins[ij[0],depth] = bin1 & bins[ij[1],depth] = bin2

  m1 = matrix & m2 = matrix

  m1[ij[1],*] = !VALUES.D_NAN & m1[*,ij[1]] = !VALUES.D_NAN

  m2[ij[0],*] = !VALUES.D_NAN & m2[*,ij[0]] = !VALUES.D_NAN

  FOR j = 0, nbin - 1 DO BEGIN

     IF k[j] EQ ij[0] OR k[j] EQ ij[1] THEN CONTINUE

     IF NOT FINITE(matrix[ij[0], k[j]]) OR NOT FINITE(matrix[ij[1], k[j]]) THEN CONTINUE

     IF NOT KEYWORD_SET(metric) THEN BEGIN

        a = matrix[ij[0], k[j]] <span class="comments">; bin1</span>

        b = matrix[ij[1], k[j]] <span class="comments">; bin2</span>

        <span class="comments">; if a>b then add k[j] to bin1 - i.e., b&lt;a</span>

     ENDIF ELSE BEGIN

        b = matrix[ij[0], k[j]] <span class="comments">; bin1</span>

        a = matrix[ij[1], k[j]] <span class="comments">; bin2</span>

        <span class="comments">; if b&lt;a then add k[j] to bin1 - i.e., a>b</span>

     ENDELSE

     IF a GT b THEN BEGIN

        bins[k[j],depth] = bin1

        m2[k[j],*] = !VALUES.D_NAN

        m2[*,k[j]] = !VALUES.D_NAN

     ENDIF ELSE BEGIN

        bins[k[j],depth] = bin2

        m1[k[j],*] = !VALUES.D_NAN

        m1[*,k[j]] = !VALUES.D_NAN

     ENDELSE

  ENDFOR

  depth++

  IF depth EQ max_depth THEN BEGIN

     MESSAGE,'HIT MAX DEPTH: DONE',/INFORMATIONAL

     RETURN

  ENDIF

  d = depth

  NODES,m1,d,max_depth,min_bins,bins,bin1,METRIC=metric

  NODES,m2,depth,max_depth,min_bins,bins,bin2,METRIC=metric

END

<span class="comments">;+</span>
<span class="comments">; Procedure performing a hierarchical clustering of PAH emission</span>
<span class="comments">; spectra based on their overlap (area).</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   REBUILD: in, optional, type=int</span>
<span class="comments">;     Wheter to rebuild the distance matrix</span>
<span class="comments">;   METRIC: in, optional, type=int</span>
<span class="comments">;     Whether to use a metric distance measure</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   Example</span>
<span class="comments">;-</span>
PRO OVERLAP_MATRIX,REBUILD=rebuild,METRIC=metric

  COMPILE_OPT IDL2

  <span class="comments">; define path to save overlap matrix</span>
  path = 'overlap_matrix.sav'

  <span class="comments">; define FWHM, frequency range, number of points</span>
  Ein = 6D * 1.6021765D-12

  FWHM = 15D

  gaussian = 0

  xrange = [20D, 2.5D]

  npoints = 400L

  <span class="comments">; read in the default database defined by the environement variable</span>
  <span class="comments">; !AMESPAHDEFAULTDB or the system variable AMESPAHDEFAULTDB. use the</span>
  <span class="comments">; keyword FILENAME if these have not been set</span>
  pahdb = OBJ_NEW('AmesPAHdbIDLSuite')

  <span class="comments">; limit ourselves to a certain set of PAHs</span>
  uids = pahdb->Search("c>20 mg=0 fe=0 si=0 o=0 chx=0 ch2=0", nuids)

  <span class="comments">; retrieve all transitions for all species from the database</span>
  transitions = pahdb->GetTransitionsByUID(uids)

  <span class="comments">; apply a PAH excitation/emission model</span>
  transitions->Cascade,Ein

  <span class="comments">; convolve into spectrum</span>
  spectrum = transitions->Convolve(FWHM=fwhm, $
                                   Xrange=1D4/xrange, $
                                   Gaussian=gaussian, $
                                   Npoints=npoints)

  <span class="comments">; obtain the spectrum for use outside object</span>
  spectrum_s = spectrum->Get()

  <span class="comments">; clean up</span>
  OBJ_DESTROY,[spectrum, transitions, pahdb]

  IF FILE_TEST(path, /READ) AND NOT KEYWORD_SET(REBUILD) THEN BEGIN

     MESSAGE,'READING MATRIX FROM ' + path,/INFORMATIONAL

     RESTORE,path

  ENDIF ELSE BEGIN

    IF KEYWORD_SET(REBUILD) AND FILE_TEST(path, /READ) THEN MESSAGE,'REBUILDING MATRIX',/INFORMATIONAL $
    ELSE MESSAGE,'BUILDING MATRIX',/INFORMATIONAL

    <span class="comments">; define matrix</span>
    matrix = DBLARR(nuids, nuids)

    <span class="comments">; fill matrix</span>
    FOR i = 0, nuids - 1 DO BEGIN

       FOR j = 0, i DO BEGIN

          IF i EQ j THEN BEGIN

             matrix[i,j] = 1D

             CONTINUE

          ENDIF

          sel1 = WHERE(spectrum_s.data.uid EQ uids[i])

          sel2 = WHERE(spectrum_s.data.uid EQ uids[j])

          IF KEYWORD_SET(METRIC) THEN matrix[i,j] = NORM(spectrum_s.data[sel2].intensity - spectrum_s.data[sel1].intensity, LNORM=2) $
          ELSE BEGIN

             upper = WHERE(spectrum_s.data[sel2].intensity GE spectrum_s.data[sel1].intensity, COMPLEMENT=lower)

             overlap = [spectrum_s.data[sel1[upper]].intensity, spectrum_s.data[sel2[lower]].intensity]

             srt = SORT([upper,lower])

             matrix[i,j] = INT_TABULATED(spectrum_s.grid, overlap[srt])

          ENDELSE

          matrix[j,i] = matrix[i,j]

       ENDFOR

    ENDFOR

    <span class="comments">; save overlap matrix to file</span>
    SAVE,matrix,FILENAME=path

  ENDELSE

  m = matrix

  FOR i = 0, nuids - 1 DO m[i,i] = !VALUES.D_NAN

  depth = 0

  parent = 0

  max_depth = 3

  bins = INTARR(nuids, max_depth)

  min_bins = 10

  NODES,m,depth,max_depth,min_bins,bins,parent,METRIC=0

  min = 0

  key = ''

  FOR i = 0, max_depth - 1 DO BEGIN

     min += 2^i

     depth = bins[*, i]

     unq = UNIQ(depth, SORT(depth))

     u = depth[unq]

     nu = N_ELEMENTS(u)

     FOR j = 0, nu - 1 DO BEGIN

        IF u[j] LT min THEN CONTINUE

        sel1 = WHERE(depth EQ u[j], nsel1)

        uids_i = uids[sel1]

        sel2 = WHERE(spectrum_s.data.uid EQ uids_i[0])

        avg = spectrum_s.data[sel2].intensity

        FOR k = 1, nsel1 - 1 DO BEGIN

           sel2 = WHERE(spectrum_s.data.uid EQ uids_i[k])

           avg += spectrum_s.data[sel2].intensity

        ENDFOR

        avg /= DOUBLE(nsel1)

        PLOT,1D4/spectrum_s.grid,1D14*avg,XTITLE='wavelength [micron]',YTITLE='intensity [x10!U-14!N erg cm]',POSITION=[0.15,0.125,0.675,0.9]

        XYOUTS,0.18,0.85,STRING(FORMAT='("BIN #:",X,I0,X,"NBIN:",X,I0)', u[j], nsel1),/NORMAL

        IF !D.NAME EQ 'X' THEN READ,key,PROMPT="Press &lt;enter> to continue..."

     ENDFOR

  ENDFOR

END
</code>
      </div>
    </div>
  </body>
</html>