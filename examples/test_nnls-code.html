<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.3 on Wed May 18 08:51:55 2022 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>test_nnls.pro (AmesPAHdbIDLSuite Manual)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="test_nnls.pro (AmesPAHdbIDLSuite Manual)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="container">
      <div class="content">
	<code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; This is an example of testing the non-negative least-squares</span>
<span class="comments">; decomposition for a number of a randomly generated spectra, built</span>
<span class="comments">; around the functionality provided by the AmesPAHdbIDLSuite and</span>
<span class="comments">; should help confirm that the it has been properly installed. The</span>
<span class="comments">; source code is annotated to guide users and developers in the inner</span>
<span class="comments">; workings of the suite.</span>
<span class="comments">;</span>
<span class="comments">; Updated versions of the NASA Ames PAH IR Spectroscopic Database and</span>
<span class="comments">; more information can be found at: `www.astrochemistry.org/pahdb &lt;https://www.astrochemistry.org/pahdb>`.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   Call the procedure directly::</span>
<span class="comments">;</span>
<span class="comments">;     IDL> test_nnls</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   Dr. Christiaan Boersma</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;   BSD licensed</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Changes::</span>
<span class="comments">;</span>
<span class="comments">;     05-16-2022</span>
<span class="comments">;     Define indices array and expand formatting. Christiaan Boersma.</span>
<span class="comments">;     08-19-2019</span>
<span class="comments">;     Documentation added. Christiaan Boersma.</span>
<span class="comments">;-</span>


<span class="comments">;+</span>
<span class="comments">; Procedure performing a non-negative least-squares decomposition.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   array (1D) of structures</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   Example</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
FUNCTION DO_NNLS

  <span class="comments">; avoid underflow messages</span>
  !EXCEPT = 0

  <span class="comments">; set number of spectra to co-add, the FWHM to be applied when</span>
  <span class="comments">; convolving, the signal-to-noise ratio and spectral range</span>
  nspectra = 20

  fwhm = 20D

  sn = 100D

  xrange = [20D, 2.5D]

  <span class="comments">; read in the default database defined by the environement variable</span>
  <span class="comments">; !AMESPAHDEFAULTDB or the system variable AMESPAHDEFAULTDB. use</span>
  <span class="comments">; the keyword FILENAME if these have not been set</span>
  pahdb = OBJ_NEW('AmesPAHdbIDLSuite')

  <span class="comments">; get the properties of all the PAHs in the database</span>
  species = pahdb->getSpeciesByUID( -1 )

  <span class="comments">; retrieve all unique identifiers</span>
  uids = (species->Get()).data.uid

  <span class="comments">; count number of unique identifiers</span>
  nuids = N_ELEMENTS(uids)

  <span class="comments">; create random selection of unique identifiers and avoid doubles</span>
  n = nspectra

  indices = LONARR(nspectra)
  WHILE n GT 0 DO BEGIN

     indices[nspectra - n] = LONG(RANDOMU(seed, n) * nuids)

     indices = indices[SORT(indices)]

     u = UNIQ(indices)

     n = nspectra - N_ELEMENTS(u)

     indices[0] = indices[u]
  ENDWHILE

  selected_uids = uids[indices]

  <span class="comments">; get the transitions for the selected species</span>
  transitions = pahdb->getTransitionsByUID(selected_uids)

  <span class="comments">; convolve the transitions in order to obtain a spectrum</span>
  spectrum = transitions->Convolve(FWHM=fwhm, /Gaussian, XRange=1D4/xrange)

  <span class="comments">; create random weights</span>
  selected_weights = REPLICATE({uid:0L, weight:0D}, nspectra)

  selected_weights.uid = selected_uids

  selected_weights.weight = RANDOMU(LONG(SYSTIME(1)), nspectra, /DOUBLE)

  <span class="comments">; co-add the spectra using the random weights</span>
  coadd = spectrum->Coadd(Weights=selected_weights)

  <span class="comments">; obtain the spectrum for use outside the object</span>
  coadd_s = coadd->Get()

  <span class="comments">; add some Gaussian noise</span>
  noise = MAX(coadd_s.data.intensity) * RANDOMN(seed, N_ELEMENTS(coadd_s.data)) / sn

  coadd_s.data.intensity += noise

  <span class="comments">; clean up</span>
  OBJ_DESTROY,[spectrum, transitions, species]

  <span class="comments">; retrieve all transitions from the database</span>
  transitions = pahdb->getTransitionsByUID( -1 )

  <span class="comments">; convolve the transitions in order to obtain a spectrum</span>
  spectrum = transitions->Convolve(FWHM=fwhm, /Gaussian, XRange=1D4/xrange)

  <span class="comments">; fit the spectrum</span>
  fit = spectrum->Fit(coadd_s.data.intensity)

  <span class="comments">; obtain the unique identifiers of the fitted species</span>
  found_uids = fit->getUIDS()

  <span class="comments">; obtain the fitted weights</span>
  found_weights = fit->getWeights()

  <span class="comments">; clean up</span>
  OBJ_DESTROY,[fit, coadd, spectrum, transitions, pahdb]

  <span class="comments">; concat selected and found unique identifiers</span>
  all_uids = [selected_uids, found_uids]

  <span class="comments">; sort all unique identifiers</span>
  srt = SORT(all_uids)

  all_uids = all_uids[srt]

  <span class="comments">; keep only one unique identifier</span>
  all_uids = all_uids[UNIQ(all_uids)]

  <span class="comments">; count all unique identifiers</span>
  nall_uids = N_ELEMENTS(all_uids)

  <span class="comments">; output header</span>
  PRINT,FORMAT='(A10,4X,A10)',"UID","weight"

  PRINT,FORMAT='(A0,X,A0,X,A0,X,A0)',"selected","found","selected","found"

  <span class="comments">; compare selected with found</span>
  FOR i = 0, nall_uids - 1 DO BEGIN

     select = WHERE(selected_uids EQ all_uids[i], count)

     IF count EQ 0 THEN BEGIN

        selected_uid = ''

        selected_weight = ''

     ENDIF ELSE BEGIN

        selected_uid = STRING(FORMAT='(I4)', selected_uids[select])

        select = WHERE(selected_weights.uid EQ all_uids[i])

        selected_weight = STRING(FORMAT='(G7.2)', selected_weights[select].weight)

     ENDELSE

     select = WHERE(found_uids EQ all_uids[i], count)

     IF count EQ 0 THEN BEGIN

        found_uid = ''

        found_weight = ''

     ENDIF ELSE BEGIN

        found_uid = STRING(FORMAT='(I4)', found_uids[select])

        select = WHERE(found_weights.uid EQ all_uids[i])

        found_weight = STRING(FORMAT='(G7.2)', found_weights[select].weight)

     ENDELSE

     PRINT,FORMAT='(A3,4X,A3,4X,A7,4X,A7)',selected_uid,found_uid,selected_weight,found_weight

  ENDFOR

  points = {x:0D, y:0D}

  FOR i = 0, nspectra - 1 DO BEGIN

     select = WHERE(selected_uids[i] EQ found_uids , nselect)

     IF nselect EQ 0 THEN found_weight = 0D $
     ELSE BEGIN

        select = WHERE(selected_uids[i] EQ found_weights.uid)

        found_weight = found_weights[select].weight

     ENDELSE

     points = [points, {x:selected_weights[i].weight, y:found_weight}]

  ENDFOR

  RETURN,points[1:*]

END

<span class="comments">;+</span>
<span class="comments">; Procedure testing non-negative least-squares decomposition.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   Example</span>
<span class="comments">;</span>
<span class="comments">;-</span>
PRO TEST_NNLS

  points = {x:0D, y:0D}

  FOR i = 0, 5 DO points = [points, DO_NNLS()]

  points = points[1:*]

  PLOT,[0,MAX(points.x)],[0,MAX(points.y)],XTITLE='input weights',YTITLE='output weights',/NODATA

  OPLOT,[0,1],[0,1],LINESTYLE=5,COLOR=2

  OPLOT,points.x,points.y,PSYM=1

END
</code>
      </div>
    </div>
  </body>
</html>