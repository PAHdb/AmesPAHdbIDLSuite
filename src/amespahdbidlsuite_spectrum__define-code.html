<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.3 on Fri Jun  2 16:34:28 2023 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>amespahdbidlsuite_spectrum__define.pro (AmesPAHdbIDLSuite Manual)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="amespahdbidlsuite_spectrum__define.pro (AmesPAHdbIDLSuite Manual)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="container">
      <div class="content">
	<code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; Class to manage a spectrum.</span>
<span class="comments">;</span>
<span class="comments">; Updated versions of the NASA Ames PAH IR Spectroscopic Database and</span>
<span class="comments">; more information can be found at: `www.astrochemistry.org/pahdb &lt;https://www.astrochemistry.org/pahdb>`.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   Create and destroy an</span>
<span class="comments">;   AmesPAHdbIDLSuite_Spectrum-instance::</span>
<span class="comments">;</span>
<span class="comments">;     IDL> spectrum = OBJ_NEW('AmesPAHdbIDLSuite_Spectrum')</span>
<span class="comments">;     IDL> spectrum->Set,data</span>
<span class="comments">;     IDL> spectrum->Plot</span>
<span class="comments">;     IDL> OBJ_DESTROY,spectrum</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   Dr. Christiaan Boersma</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;   BSD licensed</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Changes::</span>
<span class="comments">;</span>
<span class="comments">;     04-15-2023</span>
<span class="comments">;     Store unperturbed observation in MCFIT. Christiaan Boersma.</span>
<span class="comments">;     07-08-2022</span>
<span class="comments">;     Pass EXTERNAL_NNLS to FIT in MCFIT. Christiaan Boersma.</span>
<span class="comments">;     05-18-2022</span>
<span class="comments">;     Use HISTOGRAM speed-up in PLOT. Christiaan Boersma.</span>
<span class="comments">;     04-28-2022</span>
<span class="comments">;     Clean up OBSERVATION in MCFIT when internally generated.</span>
<span class="comments">;     Christiaan Boersma.</span>
<span class="comments">;     04-27-2022</span>
<span class="comments">;     Added MCFIT and corrected small typos in description of FIT.</span>
<span class="comments">;     Christiaan Boersma.</span>
<span class="comments">;     08-17-2021</span>
<span class="comments">;     Don't try and access pointer when it is not set in DESCRIPTION.</span>
<span class="comments">;     Christiaan Boersma.</span>
<span class="comments">;     05-03-2021</span>
<span class="comments">;     Avoid potential issues when self.uids and self.data.uid don't have </span>
<span class="comments">;     the same ordering. Christiaan Boersma.</span>
<span class="comments">;     05-02-2021</span>
<span class="comments">;     Added NOTICE-keyword to FIT. Christiaan Boersma.</span>
<span class="comments">;     04-30-2021</span>
<span class="comments">;     Refactored FIT to make use of matrix operation.</span>
<span class="comments">;     Christiaan Boersma.</span>
<span class="comments">;     09-19-2017</span>
<span class="comments">;     Fixed !NULL value in return for FWHM in FIT.</span>
<span class="comments">;     06-27-2016</span>
<span class="comments">;     Added EXTERNAL_NNLS-keyword to FIT. Christiaan Boersma.</span>
<span class="comments">;     03-23-2016</span>
<span class="comments">;     Removed unnecessary declaration of 'weights' in FIT. Christiaan</span>
<span class="comments">;     Boersma.</span>
<span class="comments">;     03-18-2016</span>
<span class="comments">;     Replaced [ ] with !NULL in NNLS to avoid compiler error for IDL</span>
<span class="comments">;     version older than 8. Christiaan Boersma.</span>
<span class="comments">;     11-05-2015</span>
<span class="comments">;     Added REGRID. Christiaan Boersma.</span>
<span class="comments">;     07-12-2015</span>
<span class="comments">;     Added method to FIT. Christiaan Boersma.</span>
<span class="comments">;     02-01-2015</span>
<span class="comments">;     First version of the file. Christiaan Boersma.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">;  Output spectrum description.</span>
<span class="comments">;</span>
<span class="comments">;  :Params:</span>
<span class="comments">;     Str: out, optional, type="string array"</span>
<span class="comments">;       Ouput to Str</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   INFORMATIVE</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Description,Str

  COMPILE_OPT IDL2

  ON_ERROR,2

  self->AmesPAHdbIDLSuite_Data::Description,Str

  Str = [Str, STRING(FORMAT='(A-12,":",X,g-8.4,X,A-0)', "shift", self.shift, "cm!U-1!N")]

  Str = [Str, STRING(FORMAT='(A-12,":",X,A-0)', "profile", self.profile)]

  IF PTR_VALID(self.fwhm) THEN BEGIN

    IF SIZE(*self.fwhm, /TYPE) EQ 8 THEN BEGIN

      IF N_ELEMENTS((*self.fwhm)) GT 4 THEN fwhm = (*self.fwhm)[0:3].fwhm $
      ELSE fwhm = (*self.fwhm).fwhm

      fwhm = STRJOIN(STRTRIM(STRING(FORMAT='(g-7.3)', fwhm), 2), ",")

      fwhm += ",..."

      Str = [Str, STRING(FORMAT='(A-12,":",X,A-0,X,A-0)', "FWHM", fwhm, "cm!U-1!N")]

      Str = [Str, STRING(FORMAT='(A-12,":",X,A-0)', "|_sectioned", "yes")]

    ENDIF ELSE Str = [Str, STRING(FORMAT='(A-12,":",X,g-8.4,X,A-0)', "FWHM", *self.fwhm, "cm!U-1!N")]

  ENDIF

  Str = STRJOIN(Str, "!C")

  IF N_PARAMS() GT 0 THEN RETURN

  PRINT,STRJOIN(STRSPLIT(Str, "!C", /EXTRACT, /REGEX), STRING(10B))
END

<span class="comments">;+</span>
<span class="comments">;  Plot the spectrum.</span>
<span class="comments">;</span>
<span class="comments">;  :Keywords:</span>
<span class="comments">;    Wavelength: in, optional, type=int</span>
<span class="comments">;      Whether to set the abscissa units to wavelength</span>
<span class="comments">;    Stick: in, optional, type=int</span>
<span class="comments">;      Whether to plot the spectrum as sticks</span>
<span class="comments">;    Fill: in, optional, type=int</span>
<span class="comments">;       Whether to solid-fill the spectrum</span>
<span class="comments">;    Oplot: in, optional, type=int</span>
<span class="comments">;      Whether to draw over a previous plot</span>
<span class="comments">;    Legend: in, optional, type=int</span>
<span class="comments">;      Whether to show a legend</span>
<span class="comments">;    Color: in, optional, type=int</span>
<span class="comments">;      Color to plot the spectrum with</span>
<span class="comments">;    _EXTRA: in, optional, type=struct</span>
<span class="comments">;      Required for IDL's keyword-inheritance mechanism</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   PLOTTING</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Plot,Wavelength=Wavelength,Stick=Stick,Fill=Fill,Oplot=Oplot,Legend=Legend,Color=Color,_EXTRA=EXTRA

  COMPILE_OPT IDL2

  ON_ERROR,2

  self->AmesPAHdbIDLSuite_Plot::Setup,Oplot=Oplot,XSIZE=600,YSIZE=400

  x = *self.grid

  nx = N_ELEMENTS(x)

  xunits = self.units.abscissa.str

  xrange = [MAX(x, MIN=xmin), xmin]

  IF KEYWORD_SET(Wavelength) THEN BEGIN

     x = 1D4 / x

     xrange = [MIN(x, MAX=xmax), xmax]

     xunits = 'wavelength [!Mm!Xm]'
  ENDIF

  IF NOT KEYWORD_SET(Oplot) THEN self->AmesPAHdbIDLSuite_Plot::Plot,REFORM(REBIN(x,nx,self.nuids),self.nuids*nx),(*self.data).intensity,Color=Color,XRANGE=xrange,XTITLE=xunits,YTITLE=self.units.ordinate.str,/NoData,Stick=Stick,_EXTRA=EXTRA

  IF NOT KEYWORD_SET(Color) THEN Color = 2

  h = HISTOGRAM((*self.data).uid, MIN=0, REVERSE_INDICES=ri)

  FOR i = 0, self.nuids - 1 DO BEGIN

     select = ri[ri[(*self.uids)[i]]:ri[(*self.uids)[i]+1]-1]

     self->AmesPAHdbIDLSuite_Plot::Oplot,x,(*self.data)[select].intensity,Stick=Stick,Fill=Fill,COLOR=Color+i
  ENDFOR

  IF SIZE(Legend, /TYPE) EQ 0 THEN Legend = 1

  IF Legend THEN BEGIN

     self->Description,outs

     self->AmesPAHdbIDLSuite_Plot::Legend,outs
  ENDIF

  self->AmesPAHdbIDLSuite_Plot::Restore
END

<span class="comments">;+</span>
<span class="comments">; Write the spectrum to file as an IPAC-table.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   Filename: in, optional, type=string</span>
<span class="comments">;     Output filename</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   OUTPUT</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Write,Filename

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF N_PARAMS() LT 1 THEN Filename = OBJ_CLASS(self) + '.tbl'

  timestamp = SYSTIME()
  hdr = []
  FXADDPAR,hdr,"DATE",timestamp," Date this file was generated"
  FXADDPAR,hdr,"ORIGIN","NASA Ames Research Center"," Organization generating this file"
  FXADDPAR,hdr,"CREATOR",STRING(FORMAT='("IDL",X,A0,X,"on",X,A0)', !VERSION.RELEASE, !VERSION.OS_NAME)," Software used to create this file"
  FXADDPAR,hdr,"SOFTWARE","AmesPAHdbIDLSuite"," Program used to create this file"
  FXADDPAR,hdr,"AUTHOR","Dr. C. Boersma"," Author of the program"
  FXADDPAR,hdr,"TYPE",OBJ_CLASS(self)," AmesPAHdbIDLSuite data type"

  self->Description,description

  comments = STRSPLIT(description, "!C", /EXTRACT, /REGEX, COUNT=ncomments)

  FOR i = 0L, ncomments - 1 DO FXADDPAR,hdr,"COMMENT",comments[i]

  IF self.units.abscissa.str THEN $
     abscissa = STREGEX(self.units.abscissa.str, '(.*) \[(.*)\]', /SUBEXPR, /EXTRACT) $
  ELSE $
     abscissa = ['', 'abscissa', '']

  IF self.units.ordinate.str THEN $
     ordinate = STREGEX(self.units.ordinate.str, '(.*) \[(.*)\]', /SUBEXPR, /EXTRACT) $
  ELSE $
     ordinate = ['', 'ordinate', '']

  half_abscissa_len = STRLEN(abscissa[1]) / 2
  half_ordinate_len = STRLEN(ordinate[1]) / 2

  fmt1 = '("|",A' + STRING(FORMAT='(I0)', 12 + half_abscissa_len) + ',' + STRING(FORMAT='(I0)', 13 - half_abscissa_len) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)', 12 + half_ordinate_len) + ',' + STRING(FORMAT='(I0)', 13 - half_ordinate_len) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)',  6 + 3) + ',' + STRING(FORMAT='(I0)',  6 - 3) + 'X,' + $
          '"|")'

  fmt2 = '("|",A' + STRING(FORMAT='(I0)', 12 + 3) + ',' + STRING(FORMAT='(I0)', 13 - 3) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)', 12 + 3) + ',' + STRING(FORMAT='(I0)', 13 - 3) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)',  6 + 3) + ',' + STRING(FORMAT='(I0)',  6 - 3) + 'X,' + $
          '"|")'

  half_abscissa_len = STRLEN(abscissa[2]) / 2
  half_ordinate_len = STRLEN(ordinate[2]) / 2

  fmt3 = '("|",A' + STRING(FORMAT='(I0)', 12 + half_abscissa_len) + ',' + STRING(FORMAT='(I0)', 13 - half_abscissa_len) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)', 12 + half_ordinate_len) + ',' + STRING(FORMAT='(I0)', 13 - half_ordinate_len) + 'X,' + $
          '"|",A' + STRING(FORMAT='(I0)',  6 + 3) + ',' + STRING(FORMAT='(I0)',  6 - 3) + 'X,' + $
          '"|")'

  cols = [STRING(FORMAT=fmt1,STRUPCASE(abscissa[1]),STRUPCASE(ordinate[1]),'UID'), $
          STRING(FORMAT=fmt2,"double","double","int"), $
          STRING(FORMAT=fmt3,abscissa[2],ordinate[2],"")]

  n = N_ELEMENTS(*self.grid)
  intensities = REFORM((*self.data).intensity, n, self.nuids)
  srt = SORT(*self.uids)
  intensities = intensities[*, srt]

  OPENW,funit,Filename,/GET_LUN
  PRINTF,funit,FORMAT='("\",A0)',hdr[0:WHERE(STRPOS(hdr, 'END') EQ 0)]
  PRINTF,funit,STRJOIN(cols, STRING( 10B ))
  n = N_ELEMENTS(*self.grid)

  FOR i = 0L, self.nuids - 1L DO BEGIN
     FOR j = 0L, n - 1L DO PRINTF,funit,FORMAT='(X,F25.6,X,F25.6,X,I)',(*self.grid)[j],intensities[j,i],(*self.uids)[i]
  ENDFOR
  CLOSE,funit
  FREE_LUN,funit

  PRINT
  PRINT,"========================================================="
  PRINT,"    WRITTEN IPAC TABLE: ", Filename
  PRINT,"========================================================="
  PRINT
END

<span class="comments">;+</span>
<span class="comments">;  Implementation of the non-negative least-squares algorithm.</span>
<span class="comments">;</span>
<span class="comments">;  :Params:</span>
<span class="comments">;    A: in, required, type="double array (2D)"</span>
<span class="comments">;      Matrix</span>
<span class="comments">;    b: in, required, type="double array (1D)"</span>
<span class="comments">;      Vector</span>
<span class="comments">;    tol: in, optional, type=double</span>
<span class="comments">;      Tolerance</span>
<span class="comments">;    max_iter: in, optional, type=long</span>
<span class="comments">;      Maximum number of iterations</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   FITTING</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::NNLS,A,b,tol,max_iter

  COMPILE_OPT IDL2

  ON_ERROR, 2

  IF N_PARAMS() LT 4 THEN BEGIN
     max_iter = 100
     IF N_PARAMS() LT 3 THEN tol = 1D-16
  ENDIF

  A        = DOUBLE(A)
  b        = DOUBLE(b)
  tol      = DOUBLE(tol)
  max_iter = LONG(max_iter)

  s_struct = SIZE(A, /STRUCTURE)
  m        = s_struct.dimensions[0]
  n        = s_struct.dimensions[1]
  w        = MAKE_ARRAY(m, VALUE=-1D)
  x        = DBLARR(m)
  P        = !NULL
  Z        = INDGEN(m)

  k        = 0L

  WHILE (Z NE !NULL) AND (k LT max_iter) DO BEGIN

     IF WHERE(-w[Z] GT tol, /NULL) EQ !NULL THEN BREAK

     k += 1L

     tapbp = A#b

     IF P EQ !NULL THEN BEGIN
        w     = -tapbp
     ENDIF ELSE BEGIN
        tapap = A#TRANSPOSE(A[P, *])
        w     = -tapbp + tapap#x[P]
     ENDELSE

     IF WHERE(-w[Z] GT tol, /NULL) EQ !NULL THEN BREAK

     wi      = MAX(-w[Z], i)
     P       = [P, Z[i]]
     nz      = N_ELEMENTS(Z)
     IF nz EQ 1 THEN BEGIN
        Z = !NULL
     ENDIF ELSE BEGIN
        Z = Z[WHERE(HISTOGRAM([i], MIN=0, MAX=nz-1) EQ 0)]
     ENDELSE

     WHILE 1 DO BEGIN

        zz    = DBLARR(m)
        zz[P] = LA_LEAST_SQUARES(A[P,*],b)

        IF WHERE(zz[P] LE 0, /NULL) EQ !NULL THEN BEGIN
           x = zz
           BREAK
        ENDIF

        P_ZN    = P[WHERE(zz[P] LE tol, /NULL)]
        alpha   = MIN(x[P_ZN]/(x[P_ZN] - zz[P_ZN]))
        x[P]    = x[P] + alpha*(zz[P]-x[P])
        temp    = WHERE(ABS(x[P]) LE tol, /NULL)
        Z       = [Z, P[temp]]
        np      = N_ELEMENTS(P)
        IF np EQ N_ELEMENTS(temp) THEN BEGIN
           P = !NULL
        ENDIF ELSE IF temp NE !NULL THEN BEGIN
           P = P[WHERE(HISTOGRAM(temp, MIN=0, MAX=np-1) EQ 0)]
        ENDIF
     ENDWHILE
  ENDWHILE
  b=x
  max_iter=k
END

<span class="comments">;+</span>
<span class="comments">;  Perform a spectroscopic fit.</span>
<span class="comments">;</span>
<span class="comments">;  :Returns:</span>
<span class="comments">;    AmesPAHdbIDLSuite_Fitted_Spectrum</span>
<span class="comments">;</span>
<span class="comments">;  :Params:</span>
<span class="comments">;    observation: in, required, type="double array (1D) or AmesPAHdbIDLSuite_Observation"</span>
<span class="comments">;      Observed spectrum</span>
<span class="comments">;    error: in, optional, type="double array (1D)"</span>
<span class="comments">;      Uncertainties associated with observation</span>
<span class="comments">;</span>
<span class="comments">;  :Keywords:</span>
<span class="comments">;    EXTERNAL_NNLS: in, optional, type=int</span>
<span class="comments">;     Whether to use an externally defined NNLS-routine</span>
<span class="comments">;    NOTICE: in, optional, type=int, default=1</span>
<span class="comments">;     Whether to show notices</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   FITTING</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::Fit,observation,error,EXTERNAL_NNLS=external_nnls,Notice=Notice

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF SIZE(Notice, /TYPE) EQ 0 THEN Notice = 1

  type = SIZE(observation, /STRUCTURE)

  has_error = 0

  IF type.type_name EQ 'OBJREF' THEN BEGIN

     IF OBJ_CLASS(observation) EQ 'AMESPAHDBIDLSUITE_OBSERVATION' THEN BEGIN

        observation->AbscissaUnitsTo,1,Notice=Notice

        observation_s = observation->get()

        IF NOT ARRAY_EQUAL(*self.grid, observation_s.data.x) THEN BEGIN
           PRINT
           PRINT,"========================================================="
           PRINT,"      DATA AND OBSERVATION GRIDS ARE NOT THE SAME        "
           PRINT,"========================================================="
           PRINT
           RETURN,OBJ_NEW()
        ENDIF

        IF TOTAL(observation_s.data.ystdev) GT 0 THEN has_error = 1
     ENDIF ELSE BEGIN
        PRINT
        PRINT,"========================================================="
        PRINT," OBJECT SHOULD BE AN AMESPAHDBIDLSUITE_OBSERVATION: "+type.type_name
        PRINT,"========================================================="
        PRINT
        self.state = 0
        RETURN,OBJ_NEW()
     ENDELSE
  ENDIF ELSE BEGIN

     IF N_PARAMS() GT 1 THEN BEGIN

        tmp = OBJ_NEW('AmesPAHdbIDLSuite_Observation', $
                      X=*self.grid, $
                      Y=observation, $
                      ErrY=error)

        has_error = 1
     ENDIF ELSE tmp = OBJ_NEW('AmesPAHdbIDLSuite_Observation', $
                              X=*self.grid, $
                              Y=observation)

     observation_s = tmp->get()

     OBJ_DESTROY,tmp
  ENDELSE

  ny = N_ELEMENTS(observation_s.data.y)

  matrix = TRANSPOSE(REFORM((*self.data).intensity, ny, self.nuids))

  m = matrix

  b = observation_s.data.y - observation_s.data.continuum

  IF has_error THEN BEGIN

     IF Notice THEN BEGIN
       PRINT
       PRINT,"========================================================="
       PRINT,"                     DOING NNLC                          "
       PRINT,"========================================================="
       PRINT
     ENDIF

     b /= observation_s.data.ystdev

     m /= TRANSPOSE(REBIN(observation_s.data.ystdev, ny, self.nuids))

     method = 'NNLC'
  ENDIF ELSE BEGIN
     IF Notice THEN BEGIN
       PRINT
       PRINT,"========================================================="
       PRINT,"                     DOING NNLS                          "
       PRINT,"========================================================="
       PRINT
     ENDIF

     method = 'NNLS'
  ENDELSE

  READS,!VERSION.RELEASE,idl_version

  IF idl_version GE 8.0 AND NOT KEYWORD_SET(EXTERNAL_NNLS) THEN BEGIN

     self->NNLS,m,b

     weights = b
  ENDIF ELSE IF NOT KEYWORD_SET(EXTERNAL_NNLS) THEN BEGIN
     PRINT
     PRINT,"========================================================="
     PRINT,"         FIT REQUIRES IDL VERSION 8.0 OR HIGHER: "+!VERSION.RELEASE
     PRINT,"========================================================="
     PRINT
     self.state = 0
     RETURN,OBJ_NEW()
  ENDIF ELSE BEGIN
     IF Notice THEN BEGIN
       PRINT
       PRINT,"========================================================="
       PRINT,"                   USING EXTERNAL NNLS                   "
       PRINT,"========================================================="
       PRINT
     ENDIF
     weights = DBLARR(self.nuids, /NOZERO)
     enorm = 0D
     w = DBLARR(self.nuids)
     indx = LONARR(self.nuids)
     mode = 0
     NNLS,m,ny,self.nuids,b,weights,enorm,w,indx,mode
  ENDELSE

  valid = WHERE(weights GT 0, nvalid)

  IF nvalid EQ 0 THEN BEGIN
     PRINT
     PRINT,"========================================================="
     PRINT,"                UNABLE TO FIND SOLUTION                  "
     PRINT,"========================================================="
     PRINT
     self.state = 0
     RETURN,OBJ_NEW()
  ENDIF

  IF Notice THEN BEGIN
    PRINT
    PRINT,"========================================================="
    PRINT," NOTICE: PLEASE TAKE CONSIDERABLE CARE WHEN INTERPRETING "
    PRINT," THESE RESULTS AND PUTTING THEM IN AN ASTRONOMICAL       "
    PRINT," CONTEXT. THERE ARE MANY SUBTLETIES THAT NEED TO BE TAKEN"
    PRINT," INTO ACCOUNT, RANGING FROM PAH SIZE, INCLUSION OF       "
    PRINT," HETEROATOMS, ETC. TO DETAILS OF THE APPLIED EMISSION    "
    PRINT," MODEL, BEFORE ANY THOROUGH ASSESSMENT CAN BE MADE.      "
    PRINT,"========================================================="
    PRINT
  ENDIF

  uids = (*self.data)[UNIQ((*self.data).uid)].uid

  _weights = REPLICATE({AmesPAHdbIDLSuite_Weights_S, $
                        uid:0L, $
                        weight:0D}, nvalid)

  _weights.uid = uids[valid]

  _weights.weight = weights[valid]

  data = REPLICATE({AmesPAHdbIDLSuite_Fitted_S, $
                    intensity:0D, $
                    uid:0L}, ny * nvalid)

  FOR i = 0, nvalid - 1 DO BEGIN

     data[i*ny:(i+1)*ny-1].uid = uids[valid[i]]

     data[i*ny:(i+1)*ny-1].intensity = weights[valid[i]] * REFORM(matrix[valid[i], *], /OVERWRITE)
  ENDFOR

  RETURN,OBJ_NEW('AmesPAHdbIDLSuite_Fitted_Spectrum', $
                 Type=self.type, $
                 Version=self.version, $
                 Data=data, $
                 PAHdb=self.database, $
                 Uids=uids[valid], $
                 Model=*self.model, $
                 Units=self.units, $
                 Shift=self.shift, $
                 Grid=*self.grid, $
                 Profile=self.profile, $
                 FWHM=self.fwhm NE !NULL ? *self.fwhm : !NULL, $
                 Observation=observation_s, $
                 Weights=_weights, $
                 Method=method)
END

<span class="comments">;+</span>
<span class="comments">;  Perform spectroscopic fits using a Monte Carlo approach.</span>
<span class="comments">;</span>
<span class="comments">;  :Returns:</span>
<span class="comments">;    AmesPAHdbIDLSuite_MCFitted_Spectrum</span>
<span class="comments">;</span>
<span class="comments">;  :Params:</span>
<span class="comments">;    observation: in, required, type="double array (1D) or AmesPAHdbIDLSuite_Observation"</span>
<span class="comments">;      Observed spectrum</span>
<span class="comments">;    error: in, required, type="double array (1D)"</span>
<span class="comments">;      Uncertainties associated with observation</span>
<span class="comments">;    samples: in, required, type=int</span>
<span class="comments">;      Number of Monte Carlo samples</span>
<span class="comments">;</span>
<span class="comments">;  :Keywords:</span>
<span class="comments">;    UNIFORM: in, optional, type=int</span>
<span class="comments">;     Whether to use a uniform rather than a normal distribution to permutate the errors.</span>
<span class="comments">;    EXTERNAL_NNLS: in, optional, type=int</span>
<span class="comments">;     Whether to use an externally defined NNLS-routine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   FITTING</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::MCFit,observation,error,samples,EXTERNAL_NNLS=external_nnls,Uniform=Uniform

  COMPILE_OPT IDL2

  ON_ERROR,2

  type = SIZE(observation, /STRUCTURE)

  IF type.type_name EQ 'OBJREF' THEN BEGIN

    samples = error

    obs = observation

    obs_s = obs->Get()

    y = obs_s.data.y
    ystdev = obs_s.data.ystdev
  ENDIF ELSE BEGIN

     IF N_PARAMS() GT 1 THEN $
       obs = OBJ_NEW('AmesPAHdbIDLSuite_Observation', $
                      X=*self.grid, $
                      Y=observation, $
                      ErrY=error) $
     ELSE $
       obs = OBJ_NEW('AmesPAHdbIDLSuite_Observation', $
                     X=*self.grid, $
                     Y=observation)

     y = observation
     ystdev = error
  ENDELSE

  ny = N_ELEMENTS(y)

  obj = OBJARR(samples)

  PRINT
  PRINT,"========================================================="
  PRINT,"                 DOING MONTE CARLO                       "
  PRINT,"========================================================="
  PRINT

  PRINT
  PRINT,"========================================================="
  IF KEYWORD_SET(Uniform) THEN $ 
     PRINT,"           DRAWING FROM UNIFORM DISTRIBUTION             " $
   ELSE $
     PRINT,"            DRAWING FROM NORMAL DISTRIBUTION          "
  PRINT,"========================================================="
  PRINT

  PRINT
  PRINT,"========================================================="
  FOR i = 0L, samples - 1L DO BEGIN
  
    PRINT,FORMAT='("' + STRING(13B) + 'mc:",X,I5,"/",I5,$)',i+1L,samples

    obs->Set,Y=y + ystdev * (NOT KEYWORD_SET(Uniform) ? RANDOMU(seed, ny, /DOUBLE, /NORMAL) $
                                                      : (2D * RANDOMU(seed, ny, /DOUBLE, /UNIFORM) - 1D))

    obj[i] = self->Fit(obs, EXTERNAL_NNLS=external_nnls, Notice=0)
  ENDFOR
  PRINT
  PRINT,"========================================================="

  IF type.type_name NE 'OBJREF' THEN OBJ_DESTROY,obs

  obs->Set,Y=y
  RETURN,OBJ_NEW('AmesPAHdbIDLSuite_MCFitted_Spectrum', $
                  Type=self.type, $
                  Obj=obj, $
                  Distribution=KEYWORD_SET(Uniform) ? 'uniform' : 'normal', $
                  Observation=obs)
END

<span class="comments">;+</span>
<span class="comments">;  Resample the spectrum onto a provided grid.</span>
<span class="comments">;</span>
<span class="comments">;  :Params:</span>
<span class="comments">;    grid: in, required, type="double array (1D)"</span>
<span class="comments">;      The grid</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   MANIPULATE</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Resample,grid

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF NOT PTR_VALID(self.data) THEN BEGIN
     PRINT
     PRINT,"========================================================="
     PRINT,"                         NO DATA                         "
     PRINT,"========================================================="
     PRINT
     self.state = 0
     RETURN
  ENDIF

  ngrid1 = N_ELEMENTS(grid)

  Data = REPLICATE({AmesPAHdbSpectrum_S, $
                    intensity:0D, $
                    uid:0L}, ngrid1 * self.nuids)

  ngrid2 = N_ELEMENTS(*self.grid)

  uids = (*self.data)[UNIQ((*self.data).uid)].uid

  i = 0

  FOR j = 0, ngrid1 - 1 DO BEGIN

     idx = i

     WHILE i + 1 LT ngrid2 - 1 DO BEGIN

        IF (*self.grid)[i+1] GT grid[j] THEN BREAK

        idx = [idx, ++i]
     ENDWHILE

     FOR k = 0, self.nuids - 1 DO BEGIN

        Data[k*ngrid1+j].uid = uids[k]

        IF N_ELEMENTS(idx) EQ 1 THEN BEGIN

           IF (*self.grid)[i] GE grid[0] AND (*self.grid)[i] LE grid[ngrid1-1] THEN Data[k*ngrid1+j].intensity = (*self.data)[k*ngrid2+i].intensity
        ENDIF ELSE Data[k*ngrid1+j].intensity = MEAN((*self.data)[k*ngrid2+idx].intensity)
     ENDFOR
  ENDFOR

  PTR_FREE,self.grid

  self.grid = PTR_NEW(grid)

  PTR_FREE,self.data

  self.data = PTR_NEW(Data)
END

<span class="comments">;+</span>
<span class="comments">;  Co-adds the spectra</span>
<span class="comments">;</span>
<span class="comments">;  :Returns:</span>
<span class="comments">;    AmesPAHdb_Coadded_Spectrum</span>
<span class="comments">;</span>
<span class="comments">;  :Keywords:</span>
<span class="comments">;    Weights: in, optional, type=struct</span>
<span class="comments">;      Use the provided weights when co-adding</span>
<span class="comments">;    Average: in, optional, type=int</span>
<span class="comments">;      Take the average</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   CALCULATE</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::Coadd,Weights=weights,Average=Average

  COMPILE_OPT IDL2

  ON_ERROR,2

  select1 = WHERE((*self.data).uid EQ (*self.uids)[0], nselect1)

  data = REPLICATE({AmesPAHdbIDLSuite_Coadd_S, intensity:0D}, nselect1)

  data.intensity = (*self.data)[select1].intensity

  IF KEYWORD_SET(Weights) THEN BEGIN

     select2 = WHERE(Weights.uid EQ (*self.uids)[0], nselect2)

     IF nselect2 EQ 0 THEN BEGIN
        PRINT
        PRINT,"========================================================="
        PRINT,"          NO WEIGHT DEFINED FOR UID: "+STRING(FORMAT='(I-0)',(*self.uids)[0])
        PRINT,"========================================================="
        PRINT
        self.state = 0
        RETURN,0
     ENDIF

     data.intensity *= Weights[select2].weight
  ENDIF

  FOR i = 1, self.nuids - 1 DO BEGIN

     select1 = WHERE((*self.data).uid EQ (*self.uids)[i])

     IF KEYWORD_SET(Weights) THEN BEGIN

        select2 = WHERE(Weights.uid EQ (*self.uids)[i], nselect2)

        IF nselect2 EQ 0 THEN BEGIN
           PRINT
           PRINT,"========================================================="
           PRINT,"          NO WEIGHT DEFINED FOR UID: "+STRING(FORMAT='(I-0)',(*self.uids)[i])
           PRINT,"========================================================="
           PRINT
           self.state = 0
           RETURN,0
        ENDIF

       data.intensity += Weights[select2].weight * (*self.data)[select1].intensity
    ENDIF ELSE data.intensity += (*self.data)[select1].intensity
  ENDFOR

  IF KEYWORD_SET(Average) THEN data.intensity /= self.nuids

  RETURN,OBJ_NEW('AmesPAHdbIDLSuite_Coadded_Spectrum', $
                 Type=self.type, $
                 Version=self.version, $
                 Data=data, $
                 PAHdb=self.database, $
                 Uids=*self.uids, $
                 Model=*self.model, $
                 Units=self.units, $
                 Shift=self.shift, $
                 Grid=*self.grid, $
                 Profile=self.profile, $
                 FWHM=*self.fwhm, $
                 Weights=Weights, $
                 Averaged=KEYWORD_SET(Average))
END

<span class="comments">;+</span>
<span class="comments">; Retrieves the AmesPAHdbIDLSuite_Spectrum representation in a</span>
<span class="comments">; structure.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   Structure</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   SET/GET</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::Get

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF NOT PTR_VALID(self.data) THEN RETURN, 0

  struct = self->AmesPAHdbIDLSuite_Data::Get()

  struct.type = OBJ_CLASS(self)+'_S'

  RETURN,CREATE_STRUCT(struct, 'shift', self.shift, 'grid', *self.grid, 'profile', self.profile, 'fwhm', *self.fwhm)
END

<span class="comments">;+</span>
<span class="comments">; Populates the AmesPAHdbIDLSuite_Spectrum-instance.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   Struct: in, optional, type=struct</span>
<span class="comments">;     Data structure</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   Type: in, optional, type=string</span>
<span class="comments">;     Type of Data</span>
<span class="comments">;   Version: in, optional, type=string</span>
<span class="comments">;    Versioning information</span>
<span class="comments">;   Data: in, optional, type=struct</span>
<span class="comments">;     Data structure</span>
<span class="comments">;   PAHdb: in, optional, type=pointer</span>
<span class="comments">;     Pointer to parsed database file</span>
<span class="comments">;   Uids: in, optional, type="long array (1D)"</span>
<span class="comments">;     UIDs in Data</span>
<span class="comments">;   Model: in, optional, type=string</span>
<span class="comments">;     References</span>
<span class="comments">;   Units: in, optional, type="AmesPAHdb_Units_S struct"</span>
<span class="comments">;     Units</span>
<span class="comments">;   Shift: in, optional, type=float</span>
<span class="comments">;     Shift</span>
<span class="comments">;   Grid: in, optional, type="float array"</span>
<span class="comments">;     Grid</span>
<span class="comments">;   Profile: in, optional, type=string</span>
<span class="comments">;     Profile</span>
<span class="comments">;   FWHM: in, optional, type=float</span>
<span class="comments">;     FWHM</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   SET/GET</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Set,Struct,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units,Shift=Shift,Grid=Grid,Profile=Profile,FWHM=FWHM

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF N_PARAMS() GT 0 THEN BEGIN

     tag = WHERE(TAG_NAMES(Struct) EQ 'TYPE', ntype)

     IF ntype EQ 1 THEN BEGIN

        IF Struct.(tag) EQ OBJ_CLASS(self)+'_S' THEN BEGIN

           IF NOT KEYWORD_SET(Shift) THEN self.shift = Struct.shift

           IF NOT KEYWORD_SET(Grid) THEN BEGIN

              IF PTR_VALID(self.grid) THEN PTR_FREE,self.grid

              self.grid = PTR_NEW(Struct.grid)
           ENDIF

           IF NOT KEYWORD_SET(Profile) THEN self.profile = Struct.profile

           IF NOT KEYWORD_SET(FWHM) THEN BEGIN

              IF PTR_VALID(self.fwhm) THEN PTR_FREE,self.fwhm

              self.fwhm = PTR_NEW(Struct.fwhm)
           ENDIF

           s = Struct

           s.type = 'AMESPAHDBIDLSUITE_Data_S'

           self->AmesPAHdbIDLSuite_Data::Set,Struct,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units
        ENDIF
     ENDIF
  ENDIF ELSE self->AmesPAHdbIDLSuite_Data::Set,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units

  IF KEYWORD_SET(Shift) THEN self.shift = Shift

  IF KEYWORD_SET(Grid) THEN BEGIN

     IF PTR_VALID(self.grid) THEN PTR_FREE,self.grid

     self.grid = PTR_NEW(Grid)
  ENDIF

  IF KEYWORD_SET(Profile) THEN self.profile = Profile

  IF KEYWORD_SET(FWHM) THEN BEGIN

     IF PTR_VALID(self.fwhm) THEN PTR_FREE,self.fwhm

     self.fwhm = PTR_NEW(FWHM)
  ENDIF
END

<span class="comments">;+</span>
<span class="comments">; Retrieves the abscissa valuesa.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   double array (1D)</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   SET/GET</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::GetGrid

  COMPILE_OPT IDL2

  ON_ERROR,2

  IF PTR_VALID(self.grid) THEN RETURN, *self.grid

  RETURN,0
END

<span class="comments">;+</span>
<span class="comments">; Clean-up an AmesPAHdbIDLSuite_Spectrum-instance</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   CLASS</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum::Cleanup

  COMPILE_OPT IDL2

  ON_ERROR,2

  self->AmesPAHdbIDLSuite_Plot::Cleanup

  self->AmesPAHdbIDLSuite_Data::Cleanup

  IF PTR_VALID(self.grid) THEN PTR_FREE,self.grid

  IF PTR_VALID(self.fwhm) THEN PTR_FREE,self.fwhm
END

<span class="comments">;+</span>
<span class="comments">; Create an AmesPAHdbIDLSuite_Spectrum-instance</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   AmesPAHdbIDLSuite_Spectrum-instance</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   Struct: in, optional, type=struct</span>
<span class="comments">;     Data structure</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   Type: in, optional, type=string</span>
<span class="comments">;     Type of Data</span>
<span class="comments">;   Version: in, optional, type=string</span>
<span class="comments">;    Versioning information</span>
<span class="comments">;   Data: in, optional, type=struct</span>
<span class="comments">;     Data structure</span>
<span class="comments">;   PAHdb: in, optional, type=pointer</span>
<span class="comments">;     Pointer to parsed database file</span>
<span class="comments">;   Uids: in, optional, type="long array (1D)"</span>
<span class="comments">;     UIDs in Data</span>
<span class="comments">;   Model: in, optional, type=string</span>
<span class="comments">;     References</span>
<span class="comments">;   Units: in, optional, type="AmesPAHdb_Units_S struct"</span>
<span class="comments">;     Units</span>
<span class="comments">;   Shift: in, optional, type=float</span>
<span class="comments">;     Shift</span>
<span class="comments">;   Grid: in, optional, type="float array"</span>
<span class="comments">;     Grid</span>
<span class="comments">;   Profile: in, optional, type=string</span>
<span class="comments">;     Profile</span>
<span class="comments">;   FWHM: in, optional, type=float</span>
<span class="comments">;     FWHM</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   CLASS</span>
<span class="comments">;-</span>
FUNCTION AmesPAHdbIDLSuite_Spectrum::Init,Struct,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units,Shift=Shift,Grid=Grid,Profile=Profile,FWHM=FWHM

  COMPILE_OPT IDL2

  ON_ERROR,2

  self.state = self->AmesPAHdbIDLSuite_Plot::Init()

  IF self.state EQ 1 THEN BEGIN

     IF N_PARAMS() GT 0 THEN self->Set,Struct,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units,Shift=Shift,Grid=Grid,Profile=Profile,FWHM=FWHM $
     ELSE self->Set,Type=Type,Version=Version,Data=Data,PAHdb=PAHdb,Uids=Uids,Model=Model,Units=Units,Shift=Shift,Grid=Grid,Profile=Profile,FWHM=FWHM
  ENDIF

  RETURN,self.state
END

<span class="comments">;+</span>
<span class="comments">; Defines the AmesPAHdbIDLSuite_Spectrum Class</span>
<span class="comments">;</span>
<span class="comments">; :Fields:</span>
<span class="comments">;   shift: type=double</span>
<span class="comments">;     Applied band shift</span>
<span class="comments">;   grid: type=pointer</span>
<span class="comments">;     Pointer to abscissa values</span>
<span class="comments">;   profile: type=string</span>
<span class="comments">;     Applied band profile</span>
<span class="comments">;   fwhm: type=pointer</span>
<span class="comments">;     Pointer to the FWHM of the applied band profile</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   CLASS</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
PRO AmesPAHdbIDLSuite_Spectrum__DEFINE

  COMPILE_OPT IDL2

  ON_ERROR,2

  void = {AmesPAHdbIDLSuite_Spectrum, $
          INHERITS AmesPAHdbIDLSuite_Plot, $
          INHERITS AmesPAHdbIDLSuite_Data, $
          shift:0D, $
          grid:PTR_NEW(), $
          profile:'', $
          fwhm:PTR_NEW()}
END

<span class="comments">; END OF amespahdbidlsuite_spectrum__define.pro</span>
</code>
      </div>
    </div>
  </body>
</html>